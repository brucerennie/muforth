( This file is part of muforth: https://muforth.dev/

  Copyright 2002-2024 David Frech. (Read the LICENSE for details.)

loading PIC18 Serial chat (core)

hex

( Taking inspiration from the wildly successful HC08 serial chat protocol.

  Responds to the following commands. NOTE: these are hex values!

00 - 0f  Idle   - these command bytes are ignored

10  get-version  - send 4 byte commit [little endian] to host
11  set-p        - set p - the program memory address pointer
12  set-x        - set x - the data memory address pointer
13  get-x        - get x - get the current value of the data mem ptr
14  run          - load PC from p
15  read-prog-n  - read n bytes from program memory, incr p pointer
16  read-data-n  - read n bytes from data memory, incr x pointer
17  write-data   - write a byte to data memory, incr x pointer

  These are Q-series commands for programming the flash, config, and
  eeprom.

18  set-nvm-addr - set NVMADR from p
19  nvm-read     - execute an NVM read command, return data read
1a  nvm-write    - execute an NVM write command, return status

1b - ff  Idle   - these command bytes are ignored
)

( Some useful synonyms. I don't like TBLPTR and TABLAT. They aren't
  mnemonic!)

aka TBLPTRU  equ MEMADRU
aka TBLPTRH  equ MEMADRH
aka TBLPTRL  equ MEMADRL
aka TABLAT   equ MEMDATA

( We are going to use FSR0 to point to data memory. Let's call it x.)
assembler
aka FSR0L     constant xl
aka FSR0H     constant xh
aka POSTINC0  constant @x+
forth

__meta

boot

0 ,  ( startup rjmp)

( Load device-specific support.)
.ifdef 1xk50
   ld target/PIC18/device/chat-k.mu4
.else
   ld target/PIC18/device/chat-q.mu4
.then

( Compile the first 32 bits of the current muforth Git commit. When asked
  for the version, return these four bytes, in little-endian order.)

label get-version
   muforth-commit drop 8 evaluate  >3210
   ldi  send-byte c  ldi  send-byte c  ldi  send-byte c  ldi  send-byte j  ;c

label set-p
   recv-byte c  MEMADRL ) st
   recv-byte c  MEMADRH ) st
   recv-byte c  MEMADRU ) st  ret  ;c

label set-x
   recv-byte c  xl ) st
   recv-byte c  xh ) st  ret  ;c

label get-x
   xl ) ld  send-byte c
   xh ) ld  send-byte j  ;c

( Jump indirect to p.)
label run
   MEMADRU ) ld  PCLATU ) st
   MEMADRH ) ld  PCLATH ) st
   MEMADRL ) ld  PCL    ) st  ( this jumps!) ;c

( Doing streaming reads from program memory space is critical to making
  verifying the flash fast.)

label read-prog-n
   recv-byte c  0 ,z st  ( count)
   begin  p@+  MEMDATA ) ld  send-byte c  0 ,z decsz  again  ret  ;c

( We don't necessarily need to do streaming reads from data space, but it's
  much faster to read multiple bytes at a time. The code is longer, though:
  single byte read is two instructions; multi-byte is seven!)

label read-data-n
   recv-byte c  0 ,z st  ( count)
   begin  @x+ ) ld  send-byte c  0 ,z decsz  again  ret  ;c

label write-data
   recv-byte c  @x+ ) st  ret  ;c

( Stack pointed to by z is empty descending, so 0 ,z is scratch)
label process-serial
   recv-byte c  ( command)   0f1 ( -0f) addi  0 ,z st  ( have to store it!)
   0 ,z decsnz  ( 10)  get-version j
   0 ,z decsnz  ( 11)  set-p j
   0 ,z decsnz  ( 12)  set-x j
   0 ,z decsnz  ( 13)  get-x j
   0 ,z decsnz  ( 14)  run j
   0 ,z decsnz  ( 15)  read-prog-n j
   0 ,z decsnz  ( 16)  read-data-n j
   0 ,z decsnz  ( 17)  write-data j
   0 ,z decsnz  ( 18)  set-nvm-addr j
   0 ,z decsnz  ( 19)  nvm-read j
   0 ,z decsnz  ( 1a)  nvm-write j
   ( unknown command)  ret  ;c

here  0 goto  dup \a rjmp  goto
label startup
   @ram #ram +  1-  ldz  ( empty descending *data* stack)
   chip-init c
   begin  process-serial c  again  ;c
