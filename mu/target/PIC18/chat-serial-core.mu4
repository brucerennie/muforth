( This file is part of muforth: https://muforth.dev/

  Copyright 2002-2024 David Frech. (Read the LICENSE for details.)

loading PIC18 Serial chat (core)

hex

( Taking inspiration from the wildly successful HC08 serial chat protocol.

  Responds to the following commands. NOTE: these are hex values!

00 - 0f  Idle   - these command bytes are ignored

10  GetVersion  - set p to point to the chat protocol version
11  Run         - load PC from p
12  SetP        - set p - the program memory address pointer
13  SetX        - set x - the data memory address pointer
14  ReadProg    - read a byte from program memory, incr p pointer
15  ReadData    - read a byte from data memory, incr x pointer
16  WriteData   - write a byte to data memory, incr x pointer

17 - ff  Idle   - these command bytes are ignored
)

( Some useful synonyms. I don't like TBLPTR and TABLAT. They aren't
  mnemonic!)

aka TBLPTRU  equ MEMADRU
aka TBLPTRH  equ MEMADRH
aka TBLPTRL  equ MEMADRL
aka TABLAT   equ MEMDATA

( We are going to FSR0 to point to data memory. Let's call it x.)
assembler
aka FSR0L     constant xl
aka FSR0H     constant xh
aka POSTINC0  constant @x+
forth

__meta

boot

0 ,  ( startup rjmp)

( Load device-specific support.)
.ifdef 1xk50
   ld target/PIC18/device/chat-k.mu4
.else
   ld target/PIC18/device/chat-q.mu4
.then

( Compile the first 32 bits of the current muforth Git commit. When asked
  for the version, return these four bytes, in little-endian order.)

label get-version
   muforth-commit drop 8 evaluate  >3210
   ldi  send-byte c  ldi  send-byte c  ldi  send-byte c  ldi  send-byte j  ;c

label set-p
   recv-byte c  MEMADRL ) st
   recv-byte c  MEMADRH ) st
   recv-byte c  MEMADRU ) st  ret  ;c

label set-x
   recv-byte c  xl ) st
   recv-byte c  xh ) st  ret  ;c

label get-x
   xl ) ld  send-byte c
   xh ) ld  send-byte j  ;c

( Jump indirect to p.)
label run
   MEMADRU ) ld  PCLATU ) st
   MEMADRH ) ld  PCLATH ) st
   MEMADRL ) ld  PCL    ) st  ( this jumps!) ;c

( Doing streaming reads from program memory space is critical to making
  verifying the flash fast.)

label read-prog
   recv-byte c  0 ,z st  ( count)
   begin  p@+  MEMDATA ) ld  send-byte c  0 ,z decsz  again  ret  ;c

( We don't necessarily need to do streaming reads from data space, but it's
  much faster to read multiple bytes at a time. The code is longer, though:
  single byte read is two instructions; multi-byte is seven!)

label read-data
   recv-byte c  0 ,z st  ( count)
   begin           @x+ ) ld  send-byte c  0 ,z decsz  again  ret  ;c

label write-data
   recv-byte c  @x+ ) st  ret  ;c

( Stack pointed to by z is empty descending, so 0 ,z is scratch)
label process-serial
   recv-byte c  ( command)   0f1 ( -0f) addi  0 ,z st  ( have to store it!)
   0 ,z decsnz  get-version j
   0 ,z decsnz  set-p j
   0 ,z decsnz  set-x j
   0 ,z decsnz  get-x j
   0 ,z decsnz  run j
   0 ,z decsnz  read-prog j
   0 ,z decsnz  read-data j
   0 ,z decsnz  write-data j
   ( unknown command)  ret  ;c

here  0 goto  dup \a rjmp  goto
label startup
   @ram #ram +  1-  ldz  ( empty descending *data* stack)
   chip-init c
   begin  process-serial c  again  ;c
