( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

( This is for non-Forth code that simply needs to switch stack pointers
  between two or more independent tasks. Each task has its own stack and a
  small "user area"; on every task switch a fixed set of registers - common
  to all tasks! - is pushed and popped.

  This file should be treated as a template; copy and modify it to fit your
  needs.

  The registers that are saved and restored, the number of tasks, and the
  size of the stacks are all variables that depend on your use case.)

loading AVR tasks (simple)

__meta

2 var up  ( user pointer)

( Allocate the two stacks. By making the stack + user area exactly 64
  bytes, we can xor the user pointer with 64 to switch tasks!

  If we had more tasks - the number of tasks has to be a power of two to
  use the simple technique we use here - we could do something similar by
  adding an offset to the user pointer and masking the result, so that it
  "loops" through your tasks.

  The first word - really the first *byte* - of the user area is the status
  flag; the second is the saved sp. A status of 0 means runnable; non-zero
  means stopped. Doing it this way makes it easy to use the status field as a
  counting semaphore.)

@ram #ram +
  2 cells - dup constant task1-user-area
 32 cells -     constant task2-user-area

( World's shortest multi-tasker!)
label yield
   z pushw  y pushw  0 pushw  ( XXX change this to suit your needs)
   up y ldw  ( get current user pointer)
   sp@  2 x stu  ( save sp into user area)

   ( We have to find a task to run. It's possible that an interrupt could
     wake a sleeping task, so we just try and try until something is ready.

     If one of the tasks is a chat/debug stub, its status is always 0, so
     it will always run.)

   begin
      ( Switch tasks - by xoring a bit in y!)  64 xl ldi  xl yl eor
      ( If you had more tasks, you would add and mask.)
      0 ,y xl ld ( status byte)  xl tst  0= until

   ( Found one; fall through to restore to run it.)

( XXX is there a better name for this?)
label restore
   up y stw  ( set user pointer)
   2 x ldu  sp!  ( restore sp from user area)
   0 popw  y popw  z popw  ( this has to match the pushes, in reverse)
   ret  ;c

( setup-task has to leave space for, or push a value for, every register
  mentioned in yield and restore. In this case, we are saving and restoring
  three register pairs: 0/1, y, and z. We don't care what their initial
  values are, but we have to make space for them, so that the initial restore
  which sets things running will end up with sp pointing to the right place.)

label setup-task  ( initial pc in x, user area in y)
   ( Create an initial stack frame, including starting PC.)
   y z movw  ( z is our temp "stack pointer")
   -z xl st  -z xh st  ( push pc: big endian!)
   ( push initial regs: 3*2 + 1 for empty descending fixup)
   7 z sbiw  ( reg values are all "don't care")
   2 z stu  ( save temp sp to user area)
   0 x ldiw  0 x stu  ( set status to zero: runnable)
   ret  ;c

comment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
( This is example code. It has to be loaded *after* all your other code,
  because it sets up and runs to top-level routines that make up your
  program. Consider this a template to start from.)

label task1
   ( do some init stuff)
   begin  ...  yield rcall ...  again  ;c

label task2  ( same structure as task1)  ;c

RESET handler
label start-both-tasks
   ( Before we do anything else, let's start with a clean slate, by zeroing
     the entire RAM.)

   @ram y ldiw  #ram x ldiw  g0 clr  begin  y+ g0 st  1 x sbiw  0= until

   ( Set up a temporary stack - so we can call setup-task! - below the task
     stacks. In this case there are two stacks, each 32 cells in size.)

   @ram #ram +  64 cells - 1- x ldiw  sp!-unsafe

   task1-user-area y ldiw
   task1 2/ x ldiw ( starting pc)
   setup-task rcall

   ( switch user areas)  64 xl ldi  xl yl eor
   task2 2/ x ldiw  ( starting pc)
   setup-task rcall  restore rjmp  ( this starts task2 running)  ;c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
