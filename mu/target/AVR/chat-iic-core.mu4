( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

loading AVR chat over IIC (core)

( Unlike the related simple version, this one allows streaming reads and
  writes.)

( NOTE!! Atmel calls the IIC interface "TWI" - two-wire interface. While
  I'm calling it IIC everywhere else, in this file it makes no sense to do
  anything except use Atmel's conventions, esp since several registers and
  constants have "TWI" baked into their names.)

__meta

hex

-- %0001_000 2* equ slave-addr
7 equ TWINT  ( bit#)  ( ack after all other actions)
6 equ TWEA   ( bit#)  ( enable receipt of slave address)
2 equ TWEN   ( bit#)

1 TWINT <<
1 TWEA  << or
1 TWEN  << or equ tw-reset


comment %%

Status codes for slave receive mode:

  60  own addr+write received and ACKed
  68  as above, but lost arbitration first
  70  general call addr received and ACKed
  78  as above, but lost arbitration first
  80  prev addressed with own address; data byte recvd and ACKed
  88  as above, NACKed
  90  prev addressed with general call; data byte recvd and ACKed
  98  as above, NACKed
  a0  STOP or repeated START received while in slave receive mode

Status codes for slave transmit mode:

  a8  own addr+read received and ACKed
  b0  as above, but lost arbitration first
  b8  data byte xmitted and ACKed
  c0  as above, but NACKed
  c8  last byte xmitted (TWEA=0), ACKed
%%

comment register-use

  r0/r1              is used for writing flash (via SPM instruction)
  r26/27 -- aka x -- is used for status and data bytes
  r30/31 -- aka z -- is used to point to memory

  These are also registers that are considered "scratch" by the
  meta-compiler's conventions.

register-use

( Start, stop, and run the application.)
ld target/AVR/chat-app.mu4

( Peculiar code required to send and recv bytes via I2C.)

label restart  ( pop one return, ack int, then return)
   x popw
   ( fall thru)  ;c

( Ack TWINT. Make sure TWEA and TWEN also set.)
label serial-ack  ( for chat-entry)
label ack-twint
   tw-reset xh ldi  TWCR xh sts  ret  ;c

( Wait for TWINT; read status; mask prescaler bits; return in xl)
( app-run will save and restore r0, r1 and Z.)
label wait-twint
   begin  app-run rcall  TWCR xl lds  TWINT xl sbrs  again
   TWSR xl lds  0f8 xl andi  ret  ;c

label recv-byte
   wait-twint rcall
   80 xl cpi  restart  0= until  ( restart protocol)
   TWDR xl lds  ack-twint rjmp  ;c

( This is a bit tricky! Since the host had to send a new transaction for
  the read, on the first byte we're going to see _two_ interrupts: first,
  that while addressed as a slave receiver we got a STOP or RESTART; and
  second, that we were addressed as slave+read. We have to watch for, and
  ack, both.

  If we want to send multiple bytes back to the master, we have to look for
  and accept both a8 - addressed as slave+read - and b8 - byte transmitted
  and ACKed. Our caller can sit in a loop since the host will NACK the last
  byte, and we'll get a c0 status, and restart.)

label expect-start
   wait-twint rcall
   0a0 xl cpi  restart  0= until  ( we should see START/RESTART)
   ack-twint rcall
   ( fall thru)  ;c

( Returns to caller if either we were just addressed, or the last byte
  written was ACKed by the master.)

label send-another?
   wait-twint rcall
   0e8 xl andi  0a8 xl cpi  restart  0= until  ( match a8 and b8)  ret  ;c

( After sending byte and acking interrupt, wait for ACK/NACK and only
  return to caller if ok to send another byte.)

label send-byte
   TWDR xl sts  ack-twint rcall  send-another? rjmp  ;c

( Like the read-memory commands, we expect a start/restart to initiate the
  read.)

label send-word
   x 0 movw  expect-start rcall
   0 xl mov  send-byte rcall  1 xl mov  send-byte rjmp  ;c

label recv-word
   recv-byte rcall  xl 0 mov
   recv-byte rcall  xl 1 mov  0 x movw  ret  ;c

( EEPROM read/write.)
ld target/AVR/eeprom.mu4

( Flash self-programming support.)
ld target/AVR/flash-self-prog.mu4

( Called by chat startup code.)
label serial-init
   ( Set TWI slave address from EEPROM)
   zh clr  zl clr  read-eeprom-byte rcall  1 invert xl andi  TWAR xl out

.ifdef mega168
   ( Set up SCL/SDA pins as inputs with pullups enabled: PC4 and PC5)
   xl clr  DDRC xl out  30 xl ldi  PORTC xl out

.else  ( prob mega164/324/644/1284)
   ( Set up SCL/SDA pins as inputs with pullups enabled: PC0 and PC1)
   xl clr  DDRC xl out  03 xl ldi  PORTC xl out

.then
   ret  ;c

( On reads, keep streaming bytes from memory to TWI, as long as last byte
  was ACKed.)

( Command routines.)
label read-data-cmd
   expect-start rcall
   begin    z+ xl ld  send-byte rcall  again  ;c

label read-flash-cmd
   expect-start rcall
   begin  pmz+ xl ld  send-byte rcall  again  ;c

label read-eeprom-cmd
   expect-start rcall
   begin  read-eeprom-byte rcall  1 z adiw  send-byte rcall  again  ;c

( When writing to data space - ram and i/o - keep streaming bytes from TWI
  into memory, until recv-byte gets something other than an 80 status.)

label write-data-cmd
   begin  recv-byte rcall  z+ xl st  again  ;c

label write-eeprom-cmd
   begin  recv-byte rcall  write-eeprom-byte rcall  1 z adiw  again  ;c

label write-flash-cmd
   app-stop rcall  ( sanity: stop the application and disable interrupts)
   begin  recv-word rcall  x 0 movw  recv-byte rcall ( cmd)  do-spm rcall
          2 z adiw  again  ;c

( For chat dispatch loop.)
label recv-command-byte
   wait-twint rcall
   ack-twint rcall
   60 xl cpi  recv-command-byte  0= until  ( wait until addressed as slave+write)
   recv-byte rjmp  ( cmd)  ;c

( Load chat entry, dispatch, and init.)
ld target/AVR/chat-loop.mu4
