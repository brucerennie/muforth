( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2012-2023 David Frech. (Read the LICENSE for details.)

loading AVR heartbeat (software PWM)

__meta
hex

( Output to modulate - probably connected to an LED.)
0 PORTB ( bit port) 2constant heart-led

( We want the heartbeat to be a triangle wave. The simplest way to achieve
  this, with the fewest glitches and corner cases, is to XOR a sawtooth
  wave at frequency f with a polarity square wave at f/2.)

( 00 01 02 ... fc fd fe ff 00 01 02 ... fc fd fe ff     Sawtooth
  00 00 00 ... 00 00 00 00 ff ff ff ... ff ff ff ff     Polarity
  00 01 02 ... fc fd fe ff ff fe fd ... 03 02 01 00     Output)

( These two values are modified by timer overflow interrupt.)
1 var heart-index     ( how far we are into our 256-point pwm cycle)
( heart task's status byte)

( sawtooth, polarity, and heart-output are modified by the heartbeat task,
  which is woken up every time the interrupt's increment of heart-index
  overflows.)

assembler
\a xl constant sawtooth  ( xl reg = current sawtooth pwm value)
\a xh constant polarity  ( xh reg = current polarity value - 00 or ff)
forth
1 var heart-output    ( current output pwm = sawtooth xor polarity)

( At 8M clock, timer overflows at 31.25k, or every 32us.

  We increment heart-index by 2, so software PWM loop takes 128 cycles;
  otherwise, at 8M clock the heartbeat is a bit too slow!)

TIMER0_OVF handler  ( Timer/Counter0 Overflow)
label timer0-overflow-handler
   x pushw  SREG xl in  xl push  ( push X and SREG)
   heart-index xl lds  -2 xl subi  heart-index xl sts
   0= if ( index rolled over)
      ( wake the app/heart task)
      heart-user-area xh lds  xh dec  heart-user-area xh sts
   then
   heart-output xh lds  xh xl cp ( index - output)
   u< if  heart-led cbi  ( LED on)   else
          heart-led sbi  ( LED off)  then
   ( Restore SREG, pop xl & xh, and exit handler)
   xl pop  SREG xl out  x popw  reti  ;c

label heart-init
   heart-led sbi  ( LED off)
   heart-led DDRB PORTB - + ( convert PORTx to DDRx) sbi  ( set pin as output)
   01 xl ldi  TIMSK0 xl out  ( enable TOVR0)
              TCCR0B xl out  ( set timer0 clock to CPU/1)
   00 xl ldi  TCCR0A xl out  ( set up timer0 - normal mode)
   ( leave xl set to 00!)
   heart-index xl sts  ( xl is sawtooth)
   polarity clr  ( xh is polarity)
   ret  ;c

( We use timer0 overflow to wake the heart task.)
label heart-task
   heart-init rcall
   begin
      sei  x pushw  yield call  ( long call to boot region)  x popw
      sawtooth inc  0= if  ( sawtooth rolled over)
         polarity com  ( complement)
      then
      sawtooth g0 mov  polarity g0 eor  heart-output g0 sts  ( new output trigger point)
      ( Consume one of our wakeups.)
      cli  heart-user-area g0 lds  g0 inc  heart-user-area g0 sts
   again  ;c
