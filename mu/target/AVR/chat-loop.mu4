( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

( Chat entry and command processing loop.)

__meta
hex

( Compile the first 32 bits of the current muforth Git commit. When asked
  for the version, return these four bytes, in little-endian order.)

here
   muforth-commit drop 8 evaluate  >3210  c, c, c, c,

label version-cmd
   ( here) z ldiw  ret  ;c

label set-addr-cmd
   recv-word rcall  x z movw  ret  ;c

( We treat the interrupt enable [I] bit specially. When running code we
  combine the *current* state of the I bit with the rest of the status bits
  from the stack frame. This way the user knows the state of the I bit, and
  it doesn't accidentally get set or reset just by running a piece of code.)

( Host will use set-address to set Z to new SP.)
label run-cmd
   SREG xh in  80 xh andi  ( get current I bit)
   cli  SPH zh out  SPL zl out  ( safely set SP)
   xl pop ( saved SREG)  7f xl andi  xh xl or  SREG xl out
   xl pop ( padding)
   t popw  x popw  y popw  z popw  ( pop all 4 pointer regs)
   ret  ;c

label get-status-cmd
   sp@  2 x adiw ( skip ra)  send-word rjmp  ;c

( NOTE: When we stop the app, we disable interrupts, in case it is
  using them. When it gets restarted, it is up to the app to re-enable
  interrupts.)

( To stop the app, we make the chat task the only one in the task loop by
  pointing its next pointer to itself!)

label app-stop
   cli  chat-user-area    th ldi
        chat-user-area 1+ th sts  ret  ;c

( Command dispatch.)
label command-table
   ( 10) version-cmd       rjmp
   ( 11) set-addr-cmd      rjmp
   ( 12) run-cmd           rjmp
   ( 13) get-status-cmd    rjmp

   ( We want to group the read commands together so "du" can read from the
     current memory "space".)

   ( 14) read-flash-cmd    rjmp  ( space 0)
   ( 15) read-data-cmd     rjmp  ( space 1)
   ( 16) read-eeprom-cmd   rjmp  ( space 2)

   ( 17) write-flash-cmd   rjmp
   ( 18) write-data-cmd    rjmp
   ( 19) write-eeprom-cmd  rjmp

   ( 1a) app-start         rjmp
   ( 1b) app-stop          rjmp
   ;c

label process
   recv-command-byte rcall
   10 xl subi  ( 00 to 0f become large unsigned numbers)
   process command-table - 2/ xl cpi u< if  xh clr
      command-table u2/ ( word address) negate >hilo  xl subi  xh sbci
      xl push  xh push ( big-endian!)
   then ( unknown... return, and get called again)
   ret  ;c

label chat-entry  ( callable from other code!)
   ( Unless host changes it, stacked PC points to caller - usually interact.)
   z pushw  y pushw  x pushw  t pushw  ( push all 4 pointer regs)
   SREG xl in  xh clr  ( padding)  x pushw  ( push status)

.labels. .contains catch .if
   catch rcall  ( for I2C only)
.then

   begin  process rcall  again  ;c

label interact
   begin  chat-entry rcall  again  ;c
