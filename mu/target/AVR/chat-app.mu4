( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

( Common chat code)

__meta
hex

( The app can be present or absent, running or stopped, etc. So we need
  some space to keep track of the state of the app.)

( Above the stack, reserve two bytes to be used as flags for bootloader.)

@ram #ram + ( ramend)  2 -  equ app-running
           app-running 1-   equ stack-bottom

( The app-running flag is ff when running, 00 when stopped.)

( Returns Z clear [NZ] if present. Z will be set if the vector contains ffff.
  The two ff bytes are anded together; this is ff only if both were ff.
  Then we complement that. This is 00 only if both bytes started out as ff.)

label app-present?
   0 dup ( app reset vector)  zl ldi  zh ldi  pmz+ xl ld  pmz xh ld
   xh xl and  xl com  ( if it was 0ff, it's now 00)  ret  ;c

( Returns Z clear [NZ] if running.)
label app-running?
   app-running xl lds  xl tst  ret  ;c

label app-start
   app-present? rcall  0= not if
      0ff xl ldi  app-running xl sts  ( set to true)
      0 jmp ( app's reset vector is start-hook)
   then
   xl clr  app-running xl sts  ( set to false)
   ret  ;c

( Whether or not the application-stop-hook does, we clear the interrupt
  enable flag, just to be sure.)

label app-stop
   app-running? rcall  0= not if
      application-stop-hook call
      xl clr  app-running xl sts  ( set to false)
   then  cli  ret  ;c

( If we end up running the application, caller save the chat registers so
  the application doesn't have to worry about them. We only care about Z
  and R0/R1 because we use Z for addresses and might be building up a word
  value in R0/R1 to write to flash.)

label app-run
   app-running? rcall  0= not if
      z pushw  0 pushw
      application-run-hook c
      0 popw  z popw
   then  ret  ;c
