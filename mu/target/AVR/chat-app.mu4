( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

( Common chat code)

__meta
hex

( The app can be present or absent, running or stopped, etc. So we need
  some space to keep track of the state of the app.)

( Above the stack, reserve two bytes to be used as flags for bootloader.)

@ram #ram + ( ramend)  2 -  equ app-running
           app-running 1-   equ stack-bottom

( The app-running flag is ff when running, 00 when stopped.)

( Returns Z set if present. App is present if 0000 contains 940c - a long jmp.)
label app-present?
   0 dup ( app reset vector)  zl ldi  zh ldi  pmz+ xl ld  pmz xh ld
   0c xl cpi  0= if  94 xh cpi  then  ret  ;c

( Returns Z set if running.)
label app-running?
   app-running xl lds  0ff xl cpi  begin  ret  ;c

label app-start
   xl clr  app-running xl sts  ( set to false)
   app-present? rcall  0= until
   0ff xl ldi  app-running xl sts  ( set to true)
   0 ( apps reset vector) jmp  ;c

( Whether or not the application-stop-hook does, we clear the interrupt
  enable flag, just to be sure.)

label app-stop
   app-running? rcall  0= if
      xl clr  app-running xl sts  ( set to false)
      application-stop-hook call
   then  cli  ret  ;c

( If we end up running the application, caller save the chat registers so
  the application doesn't have to worry about them. We only care about Z
  and R0/R1 because we use Z for addresses and might be building up a word
  value in R0/R1 to write to flash.)

label app-run
   app-running? rcall  0= if
   z pushw  0 pushw
   application-run-hook c
   0 popw  z popw  then  ret  ;c
